    1. 1. Introduction
    2. 2. Quick Start
    3. 3. Installation
    4.   1. 3.1. Supported Platforms
         2. 3.2. Installing a Binary Distribution
         3. 3.3. Installing Nix from Source
         4.   1. 3.3.1. Prerequisites
              2. 3.3.2. Obtaining a Source Distribution
              3. 3.3.3. Building Nix from Source
         5. 3.4. Using Nix within Docker
         6. 3.5. Security
         7.   1. 3.5.1. Single-User Mode
              2. 3.5.2. Multi-User Mode
         8. 3.6. Environment Variables
         9. 3.7. Upgrading Nix
        10. 3.8. Uninstalling Nix
    5. 4. Package Management
    6.   1. 4.1. Basic Package Management
         2. 4.2. Profiles
         3. 4.3. Garbage Collection
         4.   1. 4.3.1. Garbage Collector Roots
         5. 4.4. Sharing Packages Between Machines
         6.   1. 4.4.1. Serving a Nix store via HTTP
              2. 4.4.2. Copying Closures via SSH
              3. 4.4.3. Serving a Nix store via SSH
              4. 4.4.4. Serving a Nix store via S3
    7. 5. Nix Language
    8.   1. 5.1. Data Types
         2. 5.2. Language Constructs
         3.   1. 5.2.1. String interpolation
         4. 5.3. Operators
         5. 5.4. Derivations
         6.   1. 5.4.1. Advanced Attributes
         7. 5.5. Built-in Constants
         8. 5.6. Built-in Functions
    9. 6. Advanced Topics
   10.   1. 6.1. Remote Builds
         2. 6.2. Tuning Cores and Jobs
         3. 6.3. Verifying Build Reproducibility
         4. 6.4. Using the post-build-hook
   11. 7. Command Reference
   12.   1. 7.1. Common Options
         2. 7.2. Common Environment Variables
         3. 7.3. Main Commands
         4.   1. 7.3.1. nix-build
              2. 7.3.2. nix-shell
              3. 7.3.3. nix-store
              4.   1. 7.3.3.1. nix-store --add-fixed
                   2. 7.3.3.2. nix-store --add
                   3. 7.3.3.3. nix-store --delete
                   4. 7.3.3.4. nix-store --dump-db
                   5. 7.3.3.5. nix-store --dump
                   6. 7.3.3.6. nix-store --export
                   7. 7.3.3.7. nix-store --gc
                   8. 7.3.3.8. nix-store --generate-binary-cache-key
                   9. 7.3.3.9. nix-store --import
                  10. 7.3.3.10. nix-store --load-db
                  11. 7.3.3.11. nix-store --optimise
                  12. 7.3.3.12. nix-store --print-env
                  13. 7.3.3.13. nix-store --query
                  14. 7.3.3.14. nix-store --read-log
                  15. 7.3.3.15. nix-store --realise
                  16. 7.3.3.16. nix-store --repair-path
                  17. 7.3.3.17. nix-store --restore
                  18. 7.3.3.18. nix-store --serve
                  19. 7.3.3.19. nix-store --verify-path
                  20. 7.3.3.20. nix-store --verify
              5. 7.3.4. nix-env
              6.   1. 7.3.4.1. nix-env --delete-generations
                   2. 7.3.4.2. nix-env --install
                   3. 7.3.4.3. nix-env --list-generations
                   4. 7.3.4.4. nix-env --query
                   5. 7.3.4.5. nix-env --rollback
                   6. 7.3.4.6. nix-env --set-flag
                   7. 7.3.4.7. nix-env --set
                   8. 7.3.4.8. nix-env --switch-generation
                   9. 7.3.4.9. nix-env --switch-profile
                  10. 7.3.4.10. nix-env --uninstall
                  11. 7.3.4.11. nix-env --upgrade
         5. 7.4. Utilities
         6.   1. 7.4.1. nix-channel
              2. 7.4.2. nix-collect-garbage
              3. 7.4.3. nix-copy-closure
              4. 7.4.4. nix-daemon
              5. 7.4.5. nix-hash
              6. 7.4.6. nix-instantiate
              7. 7.4.7. nix-prefetch-url
         7. 7.5. Experimental Commands
         8.   1. 7.5.1. nix
              2. 7.5.2. nix build
              3. 7.5.3. nix bundle
              4. 7.5.4. nix copy
              5. 7.5.5. nix daemon
              6. 7.5.6. nix derivation
              7. 7.5.7. nix derivation add
              8. 7.5.8. nix derivation show
              9. 7.5.9. nix develop
             10. 7.5.10. nix doctor
             11. 7.5.11. nix edit
             12. 7.5.12. nix eval
             13. 7.5.13. nix flake
             14. 7.5.14. nix flake archive
             15. 7.5.15. nix flake check
             16. 7.5.16. nix flake clone
             17. 7.5.17. nix flake info
             18. 7.5.18. nix flake init
             19. 7.5.19. nix flake lock
             20. 7.5.20. nix flake metadata
             21. 7.5.21. nix flake new
             22. 7.5.22. nix flake prefetch
             23. 7.5.23. nix flake show
             24. 7.5.24. nix flake update
             25. 7.5.25. nix fmt
             26. 7.5.26. nix hash
             27. 7.5.27. nix hash file
             28. 7.5.28. nix hash path
             29. 7.5.29. nix hash to-base16
             30. 7.5.30. nix hash to-base32
             31. 7.5.31. nix hash to-base64
             32. 7.5.32. nix hash to-sri
             33. 7.5.33. nix help
             34. 7.5.34. nix help-stores
             35. 7.5.35. nix key
             36. 7.5.36. nix key convert-secret-to-public
             37. 7.5.37. nix key generate-secret
             38. 7.5.38. nix log
             39. 7.5.39. nix nar
             40. 7.5.40. nix nar cat
             41. 7.5.41. nix nar dump-path
             42. 7.5.42. nix nar ls
             43. 7.5.43. nix path-info
             44. 7.5.44. nix print-dev-env
             45. 7.5.45. nix profile
             46. 7.5.46. nix profile diff-closures
             47. 7.5.47. nix profile history
             48. 7.5.48. nix profile install
             49. 7.5.49. nix profile list
             50. 7.5.50. nix profile remove
             51. 7.5.51. nix profile rollback
             52. 7.5.52. nix profile upgrade
             53. 7.5.53. nix profile wipe-history
             54. 7.5.54. nix realisation
             55. 7.5.55. nix realisation info
             56. 7.5.56. nix registry
             57. 7.5.57. nix registry add
             58. 7.5.58. nix registry list
             59. 7.5.59. nix registry pin
             60. 7.5.60. nix registry remove
             61. 7.5.61. nix repl
             62. 7.5.62. nix run
             63. 7.5.63. nix search
             64. 7.5.64. nix shell
             65. 7.5.65. nix show-config
             66. 7.5.66. nix store
             67. 7.5.67. nix store add-file
             68. 7.5.68. nix store add-path
             69. 7.5.69. nix store cat
             70. 7.5.70. nix store copy-log
             71. 7.5.71. nix store copy-sigs
             72. 7.5.72. nix store delete
             73. 7.5.73. nix store diff-closures
             74. 7.5.74. nix store dump-path
             75. 7.5.75. nix store gc
             76. 7.5.76. nix store ls
             77. 7.5.77. nix store make-content-addressed
             78. 7.5.78. nix store optimise
             79. 7.5.79. nix store path-from-hash-part
             80. 7.5.80. nix store ping
             81. 7.5.81. nix store prefetch-file
             82. 7.5.82. nix store repair
             83. 7.5.83. nix store sign
             84. 7.5.84. nix store verify
             85. 7.5.85. nix upgrade-nix
             86. 7.5.86. nix why-depends
         9. 7.6. Files
        10.   1. 7.6.1. nix.conf
              2. 7.6.2. Profiles
              3.   1. 7.6.2.1. manifest.nix
                   2. 7.6.2.2. manifest.json
              4. 7.6.3. Channels
              5. 7.6.4. Default Nix expression
   13. 8. Architecture and Design
   14.   1. 8.1. File System Object
   15. 9. Protocols
   16.   1. 9.1. Serving Tarball Flakes
         2. 9.2. Derivation "ATerm" file format
   17. 10. Glossary
   18. 11. Contributing
   19.   1. 11.1. Hacking
         2. 11.2. Testing
         3. 11.3. Experimental Features
         4. 11.4. CLI guideline
         5. 11.5. C++ style guide
   20. 12. Release Notes
   21.   1. 12.1. Release 2.18 (2023-09-20)
         2. 12.2. Release 2.17 (2023-07-24)
         3. 12.3. Release 2.16 (2023-05-31)
         4. 12.4. Release 2.15 (2023-04-11)
         5. 12.5. Release 2.14 (2023-02-28)
         6. 12.6. Release 2.13 (2023-01-17)
         7. 12.7. Release 2.12 (2022-12-06)
         8. 12.8. Release 2.11 (2022-08-25)
         9. 12.9. Release 2.10 (2022-07-11)
        10. 12.10. Release 2.9 (2022-05-30)
        11. 12.11. Release 2.8 (2022-04-19)
        12. 12.12. Release 2.7 (2022-03-07)
        13. 12.13. Release 2.6 (2022-01-24)
        14. 12.14. Release 2.5 (2021-12-13)
        15. 12.15. Release 2.4 (2021-11-01)
        16. 12.16. Release 2.3 (2019-09-04)
        17. 12.17. Release 2.2 (2019-01-11)
        18. 12.18. Release 2.1 (2018-09-02)
        19. 12.19. Release 2.0 (2018-02-22)
        20. 12.20. Release 1.11.10 (2017-06-12)
        21. 12.21. Release 1.11 (2016-01-19)
        22. 12.22. Release 1.10 (2015-09-03)
        23. 12.23. Release 1.9 (2015-06-12)
        24. 12.24. Release 1.8 (2014-12-14)
        25. 12.25. Release 1.7 (2014-04-11)
        26. 12.26. Release 1.6.1 (2013-10-28)
        27. 12.27. Release 1.6 (2013-09-10)
        28. 12.28. Release 1.5.2 (2013-05-13)
        29. 12.29. Release 1.5 (2013-02-27)
        30. 12.30. Release 1.4 (2013-02-26)
        31. 12.31. Release 1.3 (2013-01-04)
        32. 12.32. Release 1.2 (2012-12-06)
        33. 12.33. Release 1.1 (2012-07-18)
        34. 12.34. Release 1.0 (2012-05-11)
        35. 12.35. Release 0.16 (2010-08-17)
        36. 12.36. Release 0.15 (2010-03-17)
        37. 12.37. Release 0.14 (2010-02-04)
        38. 12.38. Release 0.13 (2009-11-05)
        39. 12.39. Release 0.12 (2008-11-20)
        40. 12.40. Release 0.11 (2007-12-31)
        41. 12.41. Release 0.10.1 (2006-10-11)
        42. 12.42. Release 0.10 (2006-10-06)
        43. 12.43. Release 0.9.2 (2005-09-21)
        44. 12.44. Release 0.9.1 (2005-09-20)
        45. 12.45. Release 0.9 (2005-09-16)
        46. 12.46. Release 0.8.1 (2005-04-13)
        47. 12.47. Release 0.8 (2005-04-11)
        48. 12.48. Release 0.7 (2005-01-12)
        49. 12.49. Release 0.6 (2004-11-14)
        50. 12.50. Release 0.5 and earlier
     * Light
     * Rust
     * Coal
     * Navy
     * Ayu

                              Nix Reference Manual

   _____________________

                               Built-in Functions

   This section lists the functions built into the Nix language evaluator.
   All built-in functions are available through the global builtins constant.

   For convenience, some built-ins can be accessed directly:

     * derivation
     * import
     * abort
     * throw

   derivation attrs

           derivation is described in its own section.

   abort s

           Abort Nix expression evaluation and print the error message s.

   add e1 e2

           Return the sum of the numbers e1 and e2.

   all pred list

           Return true if the function pred returns true for all elements of
           list, and false otherwise.

   any pred list

           Return true if the function pred returns true for at least one
           element of list, and false otherwise.

   attrNames set

           Return the names of the attributes in the set set in an
           alphabetically sorted list. For instance, builtins.attrNames { y =
           1; x = "foo"; } evaluates to [ "x" "y" ].

   attrValues set

           Return the values of the attributes in the set set in the order
           corresponding to the sorted attribute names.

   baseNameOf s

           Return the base name of the string s, that is, everything
           following the final slash in the string. This is similar to the
           GNU basename command.

   bitAnd e1 e2

           Return the bitwise AND of the integers e1 and e2.

   bitOr e1 e2

           Return the bitwise OR of the integers e1 and e2.

   bitXor e1 e2

           Return the bitwise XOR of the integers e1 and e2.

   break v

           In debug mode (enabled using --debugger), pause Nix expression
           evaluation and enter the REPL. Otherwise, return the argument v.

   catAttrs attr list

           Collect each attribute named attr from a list of attribute sets.
           Attrsets that don't contain the named attribute are ignored. For
           example,

 builtins.catAttrs "a" [{a = 1;} {b = 0;} {a = 2;}]

           evaluates to [1 2].

   ceil double

           Converts an IEEE-754 double-precision floating-point number
           (double) to the next higher integer.

           If the datatype is neither an integer nor a "float", an evaluation
           error will be thrown.

   compareVersions s1 s2

           Compare two strings representing versions and return -1 if version
           s1 is older than version s2, 0 if they are the same, and 1 if s1
           is newer than s2. The version comparison algorithm is the same as
           the one used by nix-env -u.

   concatLists lists

           Concatenate a list of lists into a single list.

   concatMap f list

           This function is equivalent to builtins.concatLists (map f list)
           but is more efficient.

   concatStringsSep separator list

           Concatenate a list of strings with a separator between each
           element, e.g. concatStringsSep "/" ["usr" "local" "bin"] ==
           "usr/local/bin".

   deepSeq e1 e2

           This is like seq e1 e2, except that e1 is evaluated deeply: if
           it’s a list or set, its elements or attributes are also evaluated
           recursively.

   dirOf s

           Return the directory part of the string s, that is, everything
           before the final slash in the string. This is similar to the GNU
           dirname command.

   div e1 e2

           Return the quotient of the numbers e1 and e2.

   elem x xs

           Return true if a value equal to x occurs in the list xs, and false
           otherwise.

   elemAt xs n

           Return element n from the list xs. Elements are counted starting
           from 0. A fatal error occurs if the index is out of bounds.

   fetchClosure args

           Fetch a store path closure from a binary cache, and return the
           store path as a string with context.

           This function can be invoked in three ways, that we will discuss
           in order of preference.

           Fetch a content-addressed store path

           Example:

 builtins.fetchClosure {
   fromStore = "https://cache.nixos.org";
   fromPath = /nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1;
 }

           This is the simplest invocation, and it does not require the user
           of the expression to configure trusted-public-keys to ensure their
           authenticity.

           If your store path is input addressed instead of content
           addressed, consider the other two invocations.

           Fetch any store path and rewrite it to a fully content-addressed
           store path

           Example:

 builtins.fetchClosure {
   fromStore = "https://cache.nixos.org";
   fromPath = /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1;
   toPath = /nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1;
 }

           This example fetches /nix/store/r2jd... from the specified binary
           cache, and rewrites it into the content-addressed store path
           /nix/store/ldbh....

           Like the previous example, no extra configuration or privileges
           are required.

           To find out the correct value for toPath given a fromPath, use nix
           store make-content-addressed:

 # nix store make-content-addressed --from https://cache.nixos.org /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1
 rewrote '/nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1' to '/nix/store/ldbhlwhh39wha58rm61bkiiwm6j7211j-git-2.33.1'

           Alternatively, set toPath = "" and find the correct toPath in the
           error message.

           Fetch an input-addressed store path as is

           Example:

 builtins.fetchClosure {
   fromStore = "https://cache.nixos.org";
   fromPath = /nix/store/r2jd6ygnmirm2g803mksqqjm4y39yi6i-git-2.33.1;
   inputAddressed = true;
 }

           It is possible to fetch an input-addressed store path and return
           it as is. However, this is the least preferred way of invoking
           fetchClosure, because it requires that the input-addressed paths
           are trusted by the Nix configuration.

           builtins.storePath

           fetchClosure is similar to builtins.storePath in that it allows
           you to use a previously built store path in a Nix expression.
           However, fetchClosure is more reproducible because it specifies a
           binary cache from which the path can be fetched. Also, using
           content-addressed store paths does not require users to configure
           trusted-public-keys to ensure their authenticity.

           This function is only available if the fetch-closure experimental
           feature is enabled.

   fetchGit args

           Fetch a path from git. args can be a URL, in which case the HEAD
           of the repo at that URL is fetched. Otherwise, it can be an
           attribute with the following attributes (all except url optional):

              * url

                The URL of the repo.

              * name (default: basename of the URL)

                The name of the directory the repo should be exported to in
                the store.

              * rev (default: the tip of ref)

                The Git revision to fetch. This is typically a commit hash.

              * ref (default: HEAD)

                The Git reference under which to look for the requested
                revision. This is often a branch or tag name.

                By default, the ref value is prefixed with refs/heads/. As of
                2.3.0, Nix will not prefix refs/heads/ if ref starts with
                refs/.

              * submodules (default: false)

                A Boolean parameter that specifies whether submodules should
                be checked out.

              * shallow (default: false)

                A Boolean parameter that specifies whether fetching from a
                shallow remote repository is allowed. This still performs a
                full clone of what is available on the remote.

              * allRefs

                Whether to fetch all references of the repository. With this
                argument being true, it's possible to load a rev from any ref
                (by default only revs from the specified ref are supported).

           Here are some examples of how to use fetchGit.

              * To fetch a private repository over SSH:

 builtins.fetchGit {
   url = "git@github.com:my-secret/repository.git";
   ref = "master";
   rev = "adab8b916a45068c044658c4158d81878f9ed1c3";
 }

              * To fetch an arbitrary reference:

 builtins.fetchGit {
   url = "https://github.com/NixOS/nix.git";
   ref = "refs/heads/0.5-release";
 }

              * If the revision you're looking for is in the default branch
                of the git repository you don't strictly need to specify the
                branch name in the ref attribute.

                However, if the revision you're looking for is in a future
                branch for the non-default branch you will need to specify
                the the ref attribute as well.

 builtins.fetchGit {
   url = "https://github.com/nixos/nix.git";
   rev = "841fcbd04755c7a2865c51c1e2d3b045976b7452";
   ref = "1.11-maintenance";
 }

                  Note

                  It is nice to always specify the branch which a revision
                  belongs to. Without the branch being specified, the fetcher
                  might fail if the default branch changes. Additionally, it
                  can be confusing to try a commit from a non-default branch
                  and see the fetch fail. If the branch is specified the
                  fault is much more obvious.

              * If the revision you're looking for is in the default branch
                of the git repository you may omit the ref attribute.

 builtins.fetchGit {
   url = "https://github.com/nixos/nix.git";
   rev = "841fcbd04755c7a2865c51c1e2d3b045976b7452";
 }

              * To fetch a specific tag:

 builtins.fetchGit {
   url = "https://github.com/nixos/nix.git";
   ref = "refs/tags/1.9";
 }

              * To fetch the latest version of a remote branch:

 builtins.fetchGit {
   url = "ssh://git@github.com/nixos/nix.git";
   ref = "master";
 }

                Nix will refetch the branch according to the tarball-ttl
                setting.

                This behavior is disabled in pure evaluation mode.

              * To fetch the content of a checked-out work directory:

 builtins.fetchGit ./work-dir

           If the URL points to a local directory, and no ref or rev is
           given, fetchGit will use the current content of the checked-out
           files, even if they are not committed or added to Git's index. It
           will only consider files added to the Git repository, as listed by
           git ls-files.

   fetchTarball args

           Download the specified URL, unpack it and return the path of the
           unpacked tree. The file must be a tape archive (.tar) compressed
           with gzip, bzip2 or xz. The top-level path component of the files
           in the tarball is removed, so it is best if the tarball contains a
           single directory at top level. The typical use of the function is
           to obtain external Nix expression dependencies, such as a
           particular version of Nixpkgs, e.g.

 with import (fetchTarball https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz) {};

 stdenv.mkDerivation { … }

           The fetched tarball is cached for a certain amount of time (1 hour
           by default) in ~/.cache/nix/tarballs/. You can change the cache
           timeout either on the command line with --tarball-ttl
           number-of-seconds or in the Nix configuration file by adding the
           line tarball-ttl = number-of-seconds.

           Note that when obtaining the hash with nix-prefetch-url the option
           --unpack is required.

           This function can also verify the contents against a hash. In that
           case, the function takes a set instead of a URL. The set requires
           the attribute url and the attribute sha256, e.g.

 with import (fetchTarball {
   url = "https://github.com/NixOS/nixpkgs/archive/nixos-14.12.tar.gz";
   sha256 = "1jppksrfvbk5ypiqdz4cddxdl8z6zyzdb2srq8fcffr327ld5jj2";
 }) {};

 stdenv.mkDerivation { … }

           Not available in restricted evaluation mode.

   fetchurl url

           Download the specified URL and return the path of the downloaded
           file.

           Not available in restricted evaluation mode.

   filter f list

           Return a list consisting of the elements of list for which the
           function f returns true.

   filterSource e1 e2

             Warning

             filterSource should not be used to filter store paths. Since
             filterSource uses the name of the input directory while naming
             the output directory, doing so will produce a directory name in
             the form of <hash2>-<hash>-<name>, where <hash>-<name> is the
             name of the input directory. Since <hash> depends on the
             unfiltered directory, the name of the output directory will
             indirectly depend on files that are filtered out by the
             function. This will trigger a rebuild even when a filtered out
             file is changed. Use builtins.path instead, which allows
             specifying the name of the output directory.

           This function allows you to copy sources into the Nix store while
           filtering certain files. For instance, suppose that you want to
           use the directory source-dir as an input to a Nix expression, e.g.

 stdenv.mkDerivation {
   ...
   src = ./source-dir;
 }

           However, if source-dir is a Subversion working copy, then all
           those annoying .svn subdirectories will also be copied to the
           store. Worse, the contents of those directories may change a lot,
           causing lots of spurious rebuilds. With filterSource you can
           filter out the .svn directories:

 src = builtins.filterSource
   (path: type: type != "directory" || baseNameOf path != ".svn")
   ./source-dir;

           Thus, the first argument e1 must be a predicate function that is
           called for each regular file, directory or symlink in the source
           tree e2. If the function returns true, the file is copied to the
           Nix store, otherwise it is omitted. The function is called with
           two arguments. The first is the full path of the file. The second
           is a string that identifies the type of the file, which is either
           "regular", "directory", "symlink" or "unknown" (for other kinds of
           files such as device nodes or fifos — but note that those cannot
           be copied to the Nix store, so if the predicate returns true for
           them, the copy will fail). If you exclude a directory, the entire
           corresponding subtree of e2 will be excluded.

   findFile search path lookup path

           Look up the given path with the given search path.

           A search path is represented list of attribute sets with two
           attributes, prefix, and path. prefix is a relative path. path
           denotes a file system location; the exact syntax depends on the
           command line interface.

           Examples of search path attribute sets:

              * {
   prefix = "nixos-config";
   path = "/etc/nixos/configuration.nix";
 }

              * {
   prefix = "";
   path = "/nix/var/nix/profiles/per-user/root/channels";
 }

           The lookup algorithm checks each entry until a match is found,
           returning a path value of the match.

           This is the process for each entry: If the lookup path matches
           prefix, then the remainder of the lookup path (the "suffix") is
           searched for within the directory denoted by patch. Note that the
           path may need to be downloaded at this point to look inside. If
           the suffix is found inside that directory, then the entry is a
           match; the combined absolute path of the directory (now downloaded
           if need be) and the suffix is returned.

           The syntax

 <nixpkgs>

           is equivalent to:

 builtins.findFile builtins.nixPath "nixpkgs"

   flakeRefToString attrs

           Convert a flake reference from attribute set format to URL format.

           For example:

 builtins.flakeRefToString {
   dir = "lib"; owner = "NixOS"; ref = "23.05"; repo = "nixpkgs"; type = "github";
 }

           evaluates to

 "github:NixOS/nixpkgs/23.05?dir=lib"

           This function is only available if the flakes experimental feature
           is enabled.

   floor double

           Converts an IEEE-754 double-precision floating-point number
           (double) to the next lower integer.

           If the datatype is neither an integer nor a "float", an evaluation
           error will be thrown.

   foldl' op nul list

           Reduce a list by applying a binary operator, from left to right,
           e.g. foldl' op nul [x0 x1 x2 ...] = op (op (op nul x0) x1) x2)
           .... For example, foldl' (x: y: x + y) 0 [1 2 3] evaluates to 6.
           The return value of each application of op is evaluated
           immediately, even for intermediate values.

   fromJSON e

           Convert a JSON string to a Nix value. For example,

 builtins.fromJSON ''{"x": [1, 2, 3], "y": null}''

           returns the value { x = [ 1 2 3 ]; y = null; }.

   fromTOML e

           Convert a TOML string to a Nix value. For example,

 builtins.fromTOML ''
   x=1
   s="a"
   [table]
   y=2
 ''

           returns the value { s = "a"; table = { y = 2; }; x = 1; }.

   functionArgs f

           Return a set containing the names of the formal arguments expected
           by the function f. The value of each attribute is a Boolean
           denoting whether the corresponding argument has a default value.
           For instance, functionArgs ({ x, y ? 123}: ...) = { x = false; y =
           true; }.

           "Formal argument" here refers to the attributes pattern-matched by
           the function. Plain lambdas are not included, e.g. functionArgs
           (x: ...) = { }.

   genList generator length

           Generate list of size length, with each element i equal to the
           value returned by generator i. For example,

 builtins.genList (x: x * x) 5

           returns the list [ 0 1 4 9 16 ].

   genericClosure attrset

           Take an attrset with values named startSet and operator in order
           to return a list of attrsets by starting with the startSet and
           recursively applying the operator function to each item. The
           attrsets in the startSet and the attrsets produced by operator
           must contain a value named key which is comparable. The result is
           produced by calling operator for each item with a value for key
           that has not been called yet including newly produced items. The
           function terminates when no new items are produced. The resulting
           list of attrsets contains only attrsets with a unique key. For
           example,

 builtins.genericClosure {
   startSet = [ {key = 5;} ];
   operator = item: [{
     key = if (item.key / 2 ) * 2 == item.key
          then item.key / 2
          else 3 * item.key + 1;
   }];
 }

           evaluates to

 [ { key = 5; } { key = 16; } { key = 8; } { key = 4; } { key = 2; } { key = 1; } ]

   getAttr s set

           getAttr returns the attribute named s from set. Evaluation aborts
           if the attribute doesn’t exist. This is a dynamic version of the .
           operator, since s is an expression rather than an identifier.

   getContext s

           Return the string context of s.

           The string context tracks references to derivations within a
           string. It is represented as an attribute set of store derivation
           paths mapping to output names.

           Using string interpolation on a derivation will add that
           derivation to the string context. For example,

 builtins.getContext "${derivation { name = "a"; builder = "b"; system = "c"; }}"

           evaluates to

 { "/nix/store/arhvjaf6zmlyn8vh8fgn55rpwnxq0n7l-a.drv" = { outputs = [ "out" ]; }; }

   getEnv s

           getEnv returns the value of the environment variable s, or an
           empty string if the variable doesn’t exist. This function should
           be used with care, as it can introduce all sorts of nasty
           environment dependencies in your Nix expression.

           getEnv is used in Nix Packages to locate the file
           ~/.nixpkgs/config.nix, which contains user-local settings for Nix
           Packages. (That is, it does a getEnv "HOME" to locate the user’s
           home directory.)

   getFlake args

           Fetch a flake from a flake reference, and return its output
           attributes and some metadata. For example:

 (builtins.getFlake "nix/55bc52401966fbffa525c574c14f67b00bc4fb3a").packages.x86_64-linux.nix

           Unless impure evaluation is allowed (--impure), the flake
           reference must be "locked", e.g. contain a Git revision or content
           hash. An example of an unlocked usage is:

 (builtins.getFlake "github:edolstra/dwarffs").rev

           This function is only available if the flakes experimental feature
           is enabled.

   groupBy f list

           Groups elements of list together by the string returned from the
           function f called on each element. It returns an attribute set
           where each attribute value contains the elements of list that are
           mapped to the same corresponding attribute name returned by f.

           For example,

 builtins.groupBy (builtins.substring 0 1) ["foo" "bar" "baz"]

           evaluates to

 { b = [ "bar" "baz" ]; f = [ "foo" ]; }

   hasAttr s set

           hasAttr returns true if set has an attribute named s, and false
           otherwise. This is a dynamic version of the ? operator, since s is
           an expression rather than an identifier.

   hasContext s

           Return true if string s has a non-empty context. The context can
           be obtained with getContext.

   hashFile type p

           Return a base-16 representation of the cryptographic hash of the
           file at path p. The hash algorithm specified by type must be one
           of "md5", "sha1", "sha256" or "sha512".

   hashString type s

           Return a base-16 representation of the cryptographic hash of
           string s. The hash algorithm specified by type must be one of
           "md5", "sha1", "sha256" or "sha512".

   head list

           Return the first element of a list; abort evaluation if the
           argument isn’t a list or is an empty list. You can test whether a
           list is empty by comparing it with [].

   import path

           Load, parse and return the Nix expression in the file path.

           The value path can be a path, a string, or an attribute set with
           an __toString attribute or a outPath attribute (as derivations or
           flake inputs typically have).

           If path is a directory, the file default.nix in that directory is
           loaded.

           Evaluation aborts if the file doesn’t exist or contains an
           incorrect Nix expression. import implements Nix’s module system:
           you can put any Nix expression (such as a set or a function) in a
           separate file, and use it from Nix expressions in other files.

             Note

             Unlike some languages, import is a regular function in Nix.
             Paths using the angle bracket syntax (e.g., import <foo>) are
             normal path values.

           A Nix expression loaded by import must not contain any free
           variables (identifiers that are not defined in the Nix expression
           itself and are not built-in). Therefore, it cannot refer to
           variables that are in scope at the call site. For instance, if you
           have a calling expression

 rec {
   x = 123;
   y = import ./foo.nix;
 }

           then the following foo.nix will give an error:

 x + 456

           since x is not in scope in foo.nix. If you want x to be available
           in foo.nix, you should pass it as a function argument:

 rec {
   x = 123;
   y = import ./foo.nix x;
 }

           and

 x: x + 456

           (The function argument doesn’t have to be called x in foo.nix; any
           name would work.)

   intersectAttrs e1 e2

           Return a set consisting of the attributes in the set e2 which have
           the same name as some attribute in e1.

           Performs in O(n log m) where n is the size of the smaller set and
           m the larger set's size.

   isAttrs e

           Return true if e evaluates to a set, and false otherwise.

   isBool e

           Return true if e evaluates to a bool, and false otherwise.

   isFloat e

           Return true if e evaluates to a float, and false otherwise.

   isFunction e

           Return true if e evaluates to a function, and false otherwise.

   isInt e

           Return true if e evaluates to an integer, and false otherwise.

   isList e

           Return true if e evaluates to a list, and false otherwise.

   isNull e

           Return true if e evaluates to null, and false otherwise.

             Warning

             This function is deprecated; just write e == null instead.

   isPath e

           Return true if e evaluates to a path, and false otherwise.

   isString e

           Return true if e evaluates to a string, and false otherwise.

   length e

           Return the length of the list e.

   lessThan e1 e2

           Return true if the number e1 is less than the number e2, and false
           otherwise. Evaluation aborts if either e1 or e2 does not evaluate
           to a number.

   listToAttrs e

           Construct a set from a list specifying the names and values of
           each attribute. Each element of the list should be a set
           consisting of a string-valued attribute name specifying the name
           of the attribute, and an attribute value specifying its value.

           In case of duplicate occurrences of the same name, the first takes
           precedence.

           Example:

 builtins.listToAttrs
   [ { name = "foo"; value = 123; }
     { name = "bar"; value = 456; }
     { name = "bar"; value = 420; }
   ]

           evaluates to

 { foo = 123; bar = 456; }

   map f list

           Apply the function f to each element in the list list. For
           example,

 map (x: "foo" + x) [ "bar" "bla" "abc" ]

           evaluates to [ "foobar" "foobla" "fooabc" ].

   mapAttrs f attrset

           Apply function f to every element of attrset. For example,

 builtins.mapAttrs (name: value: value * 10) { a = 1; b = 2; }

           evaluates to { a = 10; b = 20; }.

   match regex str

           Returns a list if the extended POSIX regular expression regex
           matches str precisely, otherwise returns null. Each item in the
           list is a regex group.

 builtins.match "ab" "abc"

           Evaluates to null.

 builtins.match "abc" "abc"

           Evaluates to [ ].

 builtins.match "a(b)(c)" "abc"

           Evaluates to [ "b" "c" ].

 builtins.match "[[:space:]]+([[:upper:]]+)[[:space:]]+" "  FOO   "

           Evaluates to [ "FOO" ].

   mul e1 e2

           Return the product of the numbers e1 and e2.

   outputOf derivation-reference output-name

           Return the output path of a derivation, literally or using a
           placeholder if needed.

           If the derivation has a statically-known output path (i.e. the
           derivation output is input-addressed, or fixed content-addresed),
           the output path will just be returned. But if the derivation is
           content-addressed or if the derivation is itself not-statically
           produced (i.e. is the output of another derivation), a placeholder
           will be returned instead.

           derivation reference must be a string that may contain a regular
           store path to a derivation, or may be a placeholder reference. If
           the derivation is produced by a derivation, you must explicitly
           select drv.outPath. This primop can be chained arbitrarily deeply.
           For instance,

 builtins.outputOf
   (builtins.outputOf myDrv "out)
   "out"

           will return a placeholder for the output of the output of myDrv.

           This primop corresponds to the ^ sigil for derivable paths, e.g.
           as part of installable syntax on the command line.

           This function is only available if the dynamic-derivations
           experimental feature is enabled.

   parseDrvName s

           Split the string s into a package name and version. The package
           name is everything up to but not including the first dash not
           followed by a letter, and the version is everything following that
           dash. The result is returned in a set { name, version }. Thus,
           builtins.parseDrvName "nix-0.12pre12876" returns { name = "nix";
           version = "0.12pre12876"; }.

   parseFlakeRef flake-ref

           Parse a flake reference, and return its exploded form.

           For example:

 builtins.parseFlakeRef "github:NixOS/nixpkgs/23.05?dir=lib"

           evaluates to:

 { dir = "lib"; owner = "NixOS"; ref = "23.05"; repo = "nixpkgs"; type = "github"; }

           This function is only available if the flakes experimental feature
           is enabled.

   partition pred list

           Given a predicate function pred, this function returns an attrset
           containing a list named right, containing the elements in list for
           which pred returned true, and a list named wrong, containing the
           elements for which it returned false. For example,

 builtins.partition (x: x > 10) [1 23 9 3 42]

           evaluates to

 { right = [ 23 42 ]; wrong = [ 1 9 3 ]; }

   path args

           An enrichment of the built-in path type, based on the attributes
           present in args. All are optional except path:

              * path
                The underlying path.

              * name
                The name of the path when added to the store. This can used
                to reference paths that have nix-illegal characters in their
                names, like @.

              * filter
                A function of the type expected by builtins.filterSource,
                with the same semantics.

              * recursive
                When false, when path is added to the store it is with a flat
                hash, rather than a hash of the NAR serialization of the
                file. Thus, path must refer to a regular file, not a
                directory. This allows similar behavior to fetchurl. Defaults
                to true.

              * sha256
                When provided, this is the expected hash of the file at the
                path. Evaluation will fail if the hash is incorrect, and
                providing a hash allows builtins.path to be used even when
                the pure-eval nix config option is on.

   pathExists path

           Return true if the path path exists at evaluation time, and false
           otherwise.

   placeholder output

           Return a placeholder string for the specified output that will be
           substituted by the corresponding output path at build time.
           Typical outputs would be "out", "bin" or "dev".

   readDir path

           Return the contents of the directory path as a set mapping
           directory entries to the corresponding file type. For instance, if
           directory A contains a regular file B and another directory C,
           then builtins.readDir ./A will return the set

 { B = "regular"; C = "directory"; }

           The possible values for the file type are "regular", "directory",
           "symlink" and "unknown".

   readFile path

           Return the contents of the file path as a string.

   readFileType p

           Determine the directory entry type of a filesystem node, being one
           of "directory", "regular", "symlink", or "unknown".

   removeAttrs set list

           Remove the attributes listed in list from set. The attributes
           don’t have to exist in set. For instance,

 removeAttrs { x = 1; y = 2; z = 3; } [ "a" "x" "z" ]

           evaluates to { y = 2; }.

   replaceStrings from to s

           Given string s, replace every occurrence of the strings in from
           with the corresponding string in to.

           The argument to is lazy, that is, it is only evaluated when its
           corresponding pattern in from is matched in the string s

           Example:

 builtins.replaceStrings ["oo" "a"] ["a" "i"] "foobar"

           evaluates to "fabir".

   seq e1 e2

           Evaluate e1, then evaluate and return e2. This ensures that a
           computation is strict in the value of e1.

   sort comparator list

           Return list in sorted order. It repeatedly calls the function
           comparator with two elements. The comparator should return true if
           the first element is less than the second, and false otherwise.
           For example,

 builtins.sort builtins.lessThan [ 483 249 526 147 42 77 ]

           produces the list [ 42 77 147 249 483 526 ].

           This is a stable sort: it preserves the relative order of elements
           deemed equal by the comparator.

   split regex str

           Returns a list composed of non matched strings interleaved with
           the lists of the extended POSIX regular expression regex matches
           of str. Each item in the lists of matched sequences is a regex
           group.

 builtins.split "(a)b" "abc"

           Evaluates to [ "" [ "a" ] "c" ].

 builtins.split "([ac])" "abc"

           Evaluates to [ "" [ "a" ] "b" [ "c" ] "" ].

 builtins.split "(a)|(c)" "abc"

           Evaluates to [ "" [ "a" null ] "b" [ null "c" ] "" ].

 builtins.split "([[:upper:]]+)" " FOO "

           Evaluates to [ " " [ "FOO" ] " " ].

   splitVersion s

           Split a string representing a version into its components, by the
           same version splitting logic underlying the version comparison in
           nix-env -u.

   storePath path

           This function allows you to define a dependency on an already
           existing store path. For example, the derivation attribute src =
           builtins.storePath /nix/store/f1d18v1y…-source causes the
           derivation to depend on the specified path, which must exist or be
           substitutable. Note that this differs from a plain path (e.g. src
           = /nix/store/f1d18v1y…-source) in that the latter causes the path
           to be copied again to the Nix store, resulting in a new path (e.g.
           /nix/store/ld01dnzc…-source-source).

           Not available in pure evaluation mode.

           See also builtins.fetchClosure.

   stringLength e

           Return the length of the string e. If e is not a string,
           evaluation is aborted.

   sub e1 e2

           Return the difference between the numbers e1 and e2.

   substring start len s

           Return the substring of s from character position start
           (zero-based) up to but not including start + len. If start is
           greater than the length of the string, an empty string is
           returned, and if start + len lies beyond the end of the string,
           only the substring up to the end of the string is returned. start
           must be non-negative. For example,

 builtins.substring 0 3 "nixos"

           evaluates to "nix".

   tail list

           Return the second to last elements of a list; abort evaluation if
           the argument isn’t a list or is an empty list.

             Warning

             This function should generally be avoided since it's
             inefficient: unlike Haskell's tail, it takes O(n) time, so
             recursing over a list by repeatedly calling tail takes O(n^2)
             time.

   throw s

           Throw an error message s. This usually aborts Nix expression
           evaluation, but in nix-env -qa and other commands that try to
           evaluate a set of derivations to get information about those
           derivations, a derivation that throws an error is silently skipped
           (which is not the case for abort).

   toFile name s

           Store the string s in a file in the Nix store and return its path.
           The file has suffix name. This file can be used as an input to
           derivations. One application is to write builders “inline”. For
           instance, the following Nix expression combines the Nix expression
           for GNU Hello and its build script into one file:

 { stdenv, fetchurl, perl }:

 stdenv.mkDerivation {
   name = "hello-2.1.1";

   builder = builtins.toFile "builder.sh" "
     source $stdenv/setup

     PATH=$perl/bin:$PATH

     tar xvfz $src
     cd hello-*
     ./configure --prefix=$out
     make
     make install
   ";

   src = fetchurl {
     url = "http://ftp.nluug.nl/pub/gnu/hello/hello-2.1.1.tar.gz";
     sha256 = "1md7jsfd8pa45z73bz1kszpp01yw6x5ljkjk2hx7wl800any6465";
   };
   inherit perl;
 }

           It is even possible for one file to refer to another, e.g.,

 builder = let
   configFile = builtins.toFile "foo.conf" "
     # This is some dummy configuration file.
     ...
   ";
 in builtins.toFile "builder.sh" "
   source $stdenv/setup
   ...
   cp ${configFile} $out/etc/foo.conf
 ";

           Note that ${configFile} is a string interpolation, so the result
           of the expression configFile (i.e., a path like
           /nix/store/m7p7jfny445k...-foo.conf) will be spliced into the
           resulting string.

           It is however not allowed to have files mutually referring to each
           other, like so:

 let
   foo = builtins.toFile "foo" "...${bar}...";
   bar = builtins.toFile "bar" "...${foo}...";
 in foo

           This is not allowed because it would cause a cyclic dependency in
           the computation of the cryptographic hashes for foo and bar.

           It is also not possible to reference the result of a derivation.
           If you are using Nixpkgs, the writeTextFile function is able to do
           that.

   toJSON e

           Return a string containing a JSON representation of e. Strings,
           integers, floats, booleans, nulls and lists are mapped to their
           JSON equivalents. Sets (except derivations) are represented as
           objects. Derivations are translated to a JSON string containing
           the derivation’s output path. Paths are copied to the store and
           represented as a JSON string of the resulting store path.

   toPath s

           DEPRECATED. Use /. + "/path" to convert a string into an absolute
           path. For relative paths, use ./. + "/path".

   toString e

           Convert the expression e to a string. e can be:

              * A string (in which case the string is returned unmodified).

              * A path (e.g., toString /foo/bar yields "/foo/bar".

              * A set containing { __toString = self: ...; } or { outPath =
                ...; }.

              * An integer.

              * A list, in which case the string representations of its
                elements are joined with spaces.

              * A Boolean (false yields "", true yields "1").

              * null, which yields the empty string.

   toXML e

           Return a string containing an XML representation of e. The main
           application for toXML is to communicate information with the
           builder in a more structured format than plain environment
           variables.

           Here is an example where this is the case:

 { stdenv, fetchurl, libxslt, jira, uberwiki }:

 stdenv.mkDerivation (rec {
   name = "web-server";

   buildInputs = [ libxslt ];

   builder = builtins.toFile "builder.sh" "
     source $stdenv/setup
     mkdir $out
     echo "$servlets" | xsltproc ${stylesheet} - > $out/server-conf.xml ①
   ";

   stylesheet = builtins.toFile "stylesheet.xsl" ②
    "<?xml version='1.0' encoding='UTF-8'?>
     <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>
       <xsl:template match='/'>
         <Configure>
           <xsl:for-each select='/expr/list/attrs'>
             <Call name='addWebApplication'>
               <Arg><xsl:value-of select=\"attr[@name = 'path']/string/@value\" /></Arg>
               <Arg><xsl:value-of select=\"attr[@name = 'war']/path/@value\" /></Arg>
             </Call>
           </xsl:for-each>
         </Configure>
       </xsl:template>
     </xsl:stylesheet>
   ";

   servlets = builtins.toXML [ ③
     { path = "/bugtracker"; war = jira + "/lib/atlassian-jira.war"; }
     { path = "/wiki"; war = uberwiki + "/uberwiki.war"; }
   ];
 })

           The builder is supposed to generate the configuration file for a
           Jetty servlet container. A servlet container contains a number of
           servlets (*.war files) each exported under a specific URI prefix.
           So the servlet configuration is a list of sets containing the path
           and war of the servlet (①). This kind of information is difficult
           to communicate with the normal method of passing information
           through an environment variable, which just concatenates
           everything together into a string (which might just work in this
           case, but wouldn’t work if fields are optional or contain lists
           themselves). Instead the Nix expression is converted to an XML
           representation with toXML, which is unambiguous and can easily be
           processed with the appropriate tools. For instance, in the example
           an XSLT stylesheet (at point ②) is applied to it (at point ①) to
           generate the XML configuration file for the Jetty server. The XML
           representation produced at point ③ by toXML is as follows:

 <?xml version='1.0' encoding='utf-8'?>
 <expr>
   <list>
     <attrs>
       <attr name="path">
         <string value="/bugtracker" />
       </attr>
       <attr name="war">
         <path value="/nix/store/d1jh9pasa7k2...-jira/lib/atlassian-jira.war" />
       </attr>
     </attrs>
     <attrs>
       <attr name="path">
         <string value="/wiki" />
       </attr>
       <attr name="war">
         <path value="/nix/store/y6423b1yi4sx...-uberwiki/uberwiki.war" />
       </attr>
     </attrs>
   </list>
 </expr>

           Note that we used the toFile built-in to write the builder and the
           stylesheet “inline” in the Nix expression. The path of the
           stylesheet is spliced into the builder using the syntax xsltproc
           ${stylesheet}.

   trace e1 e2

           Evaluate e1 and print its abstract syntax representation on
           standard error. Then return e2. This function is useful for
           debugging.

   traceVerbose e1 e2

           Evaluate e1 and print its abstract syntax representation on
           standard error if --trace-verbose is enabled. Then return e2. This
           function is useful for debugging.

   tryEval e

           Try to shallowly evaluate e. Return a set containing the
           attributes success (true if e evaluated successfully, false if an
           error was thrown) and value, equalling e if successful and false
           otherwise. tryEval will only prevent errors created by throw or
           assert from being thrown. Errors tryEval will not catch are for
           example those created by abort and type errors generated by
           builtins. Also note that this doesn't evaluate e deeply, so let e
           = { x = throw ""; }; in (builtins.tryEval e).success will be true.
           Using builtins.deepSeq one can get the expected result: let e = {
           x = throw ""; }; in (builtins.tryEval (builtins.deepSeq e
           e)).success will be false.

   typeOf e

           Return a string representing the type of the value e, namely
           "int", "bool", "string", "path", "null", "set", "list", "lambda"
           or "float".

   zipAttrsWith f list

           Transpose a list of attribute sets into an attribute set of lists,
           then apply mapAttrs.

           f receives two arguments: the attribute name and a non-empty list
           of all values encountered for that attribute name.

           The result is an attribute set where the attribute names are the
           union of the attribute names in each element of list. The
           attribute values are the return values of f.

 builtins.zipAttrsWith
   (name: values: { inherit name values; })
   [ { a = "x"; } { a = "y"; b = "z"; } ]

           evaluates to

 {
   a = { name = "a"; values = [ "x" "y" ]; };
   b = { name = "b"; values = [ "z" ]; };
 }
